### Implemente o TAD string

#### Parte I

Você deve implementar um TAD para a manipulação de strings em C, com alocação dinâmica de memória, seguindo as convenções da disciplina, com a interface definida em [str.h](str.h).

Exemplos de testes:
```c
  Str s1, s2, s3, s4;
  s1 = str_cria("aba");
  s2 = str_cria("caxi");
  s3 = str_cria("abacaxi");
  str_altera(s1, -1, 0, s2);
  assert(str_igual(s1, s3));
  s4 = str_substr(s2, 20, 10);
  assert(str_tam(s4) == 0);
  str_altera(s3, 0, 3, s4);
  assert(str_igual(s2, s3));
```

#### Parte II

Implemente suporte parcial a strings no formato UTF-8. 
Em UTF-8, um caractere pode ocupar entre 1 e 4 bytes.
A interface continua a mesma, mas todas as posições e tamanhos referem-se a caracteres e não a bytes.
As funções de acesso a caracteres (`str_char` e `str_poschar`) o caractere representa o código unicode do caractere (um valor entre 0 e 1114111).

Adicione a função `str_numbytes`, que retorna o número de bytes ocupados pela string.

Teremos um suporte bem parcial a unicode, vamos considerar que cada código represente um caractere, ignorando que no padrão alguns códigos não representam caracteres e alguns combinam-se para gerar caracteres compostos.

Para facilitar a implementação, considere usar as funções abaixo.

```c
   // retorna o número de bytes usados por um caractere codificado em UTF8 iniciando pelo byte em 'b'
   int utf8_num_bytes(char b)
   {
     // se o byte for 0xxxxxxx, o caractere ocupa só um byte (código entre 0000 e 007F)
     if ((b & 0b10000000) == 0b00000000) return 1;
     // se o byte for 110xxxxx, o caractere ocupa 2 bytes, 5 bits no primeiro e 6 no segundo (0080 a 07FF)
     if ((b & 0b11100000) == 0b11000000) return 2;
     // se o byte for 1110xxxx, o caractere ocupa 3 bytes, 4 bits no primeiro e 6 nos outros (0800 a FFFF)
     if ((b & 0b11110000) == 0b11100000) return 3;
     // se o byte for 11110xxx, o caractere ocupa 4 bytes, 3 bits no primeiro e 6 nos outros (10000 a 10FFFF)
     if ((b & 0b11111000) == 0b11110000) return 4;
     // se começar com outra coisa, temos um problema
     return 0;
   }
   
   // retorna o código do caractere armazenado em UTF-8 a partir de 'p'
   int utf8_para_codigo_unicode(char *p)
   {
     int n = utf8_num_bytes(p[0]);
     if (n == 0) return 0; // erro!
     if (n == 1) return p[0];
     if (n == 2) return ((p[0] & 0b00011111) <<  6) 
                      |  (p[1] & 0b00111111);
     if (n == 3) return ((p[0] & 0b00001111) << 12)
                      | ((p[1] & 0b00111111) <<  6)
                      |  (p[2] & 0b00111111);
     if (n == 4) return ((p[0] & 0b00000111) << 18)
                      | ((p[1] & 0b00111111) << 12)
                      | ((p[2] & 0b00111111) << 6)
                      |  (p[3] & 0b00111111);
     // erro se chegar aqui
   }
   
   // converte o código do caractere 'c' para string UTF-8 a partir de 's' (que tem que ter espaço para 5 char)
   void utf8_de_codigo_unicode(int c, char s[5])
   {
     if (c <= 0x00FF) {
       s[0] =   c;
       s[1] = '\0';
     } else if (c <= 0x07FF) {
       s[0] =  (c >>  6)               | 0b11000000;
       s[1] = ( c        & 0b00111111) | 0b10000000;
       s[2] = '\0';
     } else if (c <= 0xFFFF) {
       s[0] =  (c >> 12)               | 0b11100000;
       s[1] = ((c >>  6) & 0b00111111) | 0b10000000;
       s[2] = ( c        & 0b00111111) | 0b10000000;
       s[3] = '\0';
     } else if (c <= 0x10FFFF) {
       s[0] =  (c >> 18)               | 0b11100000;
       s[1] = ((c >> 12) & 0b00111111) | 0b10000000;
       s[2] = ((c >>  6) & 0b00111111) | 0b10000000;
       s[3] = ( c        & 0b00111111) | 0b10000000;
       s[4] = '\0';
     } else {
       // erro!
       s[0] = '\0';
     }
   }
```
